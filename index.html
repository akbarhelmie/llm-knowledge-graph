<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>LLM Knowledge Graph - Evolved</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        body { margin:0; overflow:hidden; font-family:'Nunito',sans-serif; background:#0c101a; color:#f0f0f0; }
        canvas { display:block; }
        #info {
            position: absolute; top: 10px; left: 10px; background: rgba(12,16,26,0.88);
            backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.06);
            padding:12px; border-radius:8px; z-index: 100; width:360px;
            max-height:92vh; overflow-y:auto; font-size:14px;
        }
        #search-container { position: relative; }
        #search-box {
            background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.08);
            padding:8px 10px; border-radius:6px; width:100%; color:white; margin-bottom:8px;
        }
        #search-suggestions { position:absolute; width:100%; top:44px; background:rgba(30,41,59,0.95); border-radius:6px; max-height:200px; overflow:auto; z-index:101; }
        .suggestion-item { padding:8px 10px; cursor:pointer; }
        .suggestion-item:hover { background:rgba(71,85,105,0.8); }
        .node-label{ background:transparent; color:#f0f8ff; text-shadow:0 0 5px rgba(0,0,0,1); pointer-events: all; cursor:pointer; font-size:11px; font-weight:700; }
        .edge-relation-label{ background:transparent; color:#a0aec0; text-shadow:0 0 5px rgba(0,0,0,1); pointer-events: all; cursor:pointer; font-size:9px; font-style:italic; }
        #node-inspector-display { border-top:1px solid #4A5568; margin-top: 10px; padding-top: 8px; }
        #node-inspector-display h2 { color:#90cdf4; font-weight:700; }
        #music-controls { margin-top:0.6rem; display:flex; gap:8px; align-items:center; }
        #music-controls button { background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.08); padding:6px 10px; border-radius:6px; color:white; cursor:pointer; }
        #music-status { font-size:12px; color:#cbd5e1; }
    </style>
</head>
<body>
    <div id="info" aria-live="polite">
        <h1 style="font-weight:700;font-size:16px;margin:0 0 8px 0;">Evolved Knowledge Graph</h1>

        <div id="search-container">
            <input id="search-box" type="text" placeholder="Type node to see relations..." autocomplete="off" />
            <div id="search-suggestions"></div>
        </div>

        <div id="node-inspector-display" style="display:none;">
            <h2 id="node-inspector-title">Node Details:</h2>
            <p><strong>ID:</strong> <span id="node-id-text"></span></p>
            <p><strong>Type:</strong> <span id="node-type-text"></span></p>
            <p><strong>Category:</strong> <span id="node-category-text"></span></p>
            <div id="node-connections-details" style="display:none;">
                <p><strong>Direct Connections:</strong></p>
                <ul id="node-connections-list"></ul>
            </div>
        </div>

        <div id="music-controls">
            <button id="music-toggle">Play Music</button>
            <div id="music-status">Stopped</div>
        </div>

        <div style="margin-top:8px; font-size:12px; color:#9ca3af;">
            Tip: click any node label or the canvas to interact. Music playback may require a user click (browser autoplay rules).
        </div>
    </div>

    <!-- Three & extras -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>

    <script>
    // ---------- CONFIG ----------
    const BG_AUDIO_SRC = 'assets/daft_punk_end_of_line.mp3'; // <- upload this file in your repo under /assets/
    const NODE_SIZE = 1;
    const DNA_STRAND_RADIUS = 0.04;
    const DNA_HELIX_RADIUS = 0.25;
    const HIGHLIGHT_COLOR = new THREE.Color(0xffff00);

    // ---------- DATA (kept minimal here) ----------
    // You already have a large fullGraphData in your working file.
    // If you want to use your original, paste the full JSON into fullGraphData below.
    const graphDataFull = { nodes: [], edges: [] };
    const nodeColorsFull = {};

    // ---------- GLOBALS ----------
    let scene, camera, renderer, labelRenderer, controls, raycaster, mouse, clock;
    let graphGroup;
    const nodes = new Map();
    const edges = [];
    let searchIndex = [];
    let highlightedElements = null;
    const FAINT_OPACITY = 0.05;
    const NORMAL_NODE_OPACITY = 0.8;
    const DEFAULT_RING_OPACITY = 0.4;
    const AKBAR_RING_OPACITY = DEFAULT_RING_OPACITY * 0.25;
    const AKBAR_RING_COLOR = new THREE.Color(0xe0e0e0);
    const HIGHLIGHT_OPACITY = 1.0;
    let autoRotationSpeed = 0.0003;
    let isGraphDragging = false;

    // DOM
    let nodeInspectorDisplay, nodeIdText, nodeTypeText, nodeCategoryText, nodeConnectionsDetails, nodeConnectionsList, searchBox, searchSuggestions;
    let musicToggleBtn, musicStatusDiv, audioPlayer;

    // --- Simple shaders (vertex + fragment) for flow effect ---
    const flowVertexShader = `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;
    const flowFragmentShader = `
        uniform vec3 uColor;
        uniform float uTime;
        uniform float uFlowSpeed;
        uniform float uIsHighlighted;
        varying vec2 vUv;
        void main() {
            float flow = sin(vUv.x * 30.0 + uTime * uFlowSpeed) * 0.5 + 0.5;
            flow = pow(flow, 4.0);
            vec3 baseColor = uColor;
            float baseAlpha = 0.35;
            if (uIsHighlighted > 0.5) {
                baseColor = vec3(1.0, 1.0, 0.0);
                baseAlpha = 0.9;
            }
            vec3 finalColor = baseColor + baseColor * flow * 3.0;
            gl_FragColor = vec4(finalColor, baseAlpha);
        }
    `;

    // ---------- UTIL ----------
    function getSimpleFrenetFrames(curve, segments) {
        const points = [], tangents = [], normals = [], binormals = [];
        let lastNormal = new THREE.Vector3(0, 1, 0);
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            points.push(curve.getPointAt(t));
            const tangent = curve.getTangentAt(t).normalize();
            tangents.push(tangent);
            let normal;
            if (Math.abs(tangent.y) > 0.999) normal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(1,0,0)).normalize();
            else normal = new THREE.Vector3().crossVectors(tangent, new THREE.Vector3(0,1,0)).normalize();
            if (i > 0 && normal.dot(lastNormal) < 0) normal.negate();
            normals.push(normal);
            lastNormal = normal;
            const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();
            binormals.push(binormal);
        }
        return { points, tangents, normals, binormals };
    }

    function getNodeCategory(node) {
        const type = node.type || '';
        if (type.endsWith('Value')) return 'Core Values';
        if (type.endsWith('Goal') || type === 'Belief') return 'Life Purpose & Goals';
        if (type.endsWith('Source')) return 'Sources of Knowledge';
        if (type.endsWith('Problem')) return 'Problems to Solve';
        if (type.endsWith('Role') || type.endsWith('FocusArea') || type.endsWith('Method')) return 'Leadership Roles';
        if (type.endsWith('Domain')) return 'Core Domains';
        if (type === 'Person') return 'Person';
        return 'Key Concepts';
    }

    function relationToColor(str) {
        let hash = 0;
        for (let i=0;i<str.length;i++){ hash = str.charCodeAt(i) + ((hash<<5)-hash); }
        const color = (hash & 0x00FFFFFF).toString(16).toUpperCase();
        return parseInt("00000".substring(0, 6 - color.length) + color, 16);
    }

    // ---------- CORE ----------
    function init() {
        if (!THREE) { console.error('THREE missing'); return; }
        if (!THREE.OrbitControls) console.warn('OrbitControls not found — interactions may fail.');
        if (!THREE.CSS2DRenderer) console.warn('CSS2DRenderer not found — labels may not render.');

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
        camera.position.set(0, 0, 60);
        clock = new THREE.Clock();
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Label renderer (CSS2DRenderer)
        labelRenderer = new THREE.CSS2DRenderer();
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        // allow pointer events so labels can be clicked
        labelRenderer.domElement.style.pointerEvents = 'auto';
        document.body.appendChild(labelRenderer.domElement);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 5;
        controls.maxDistance = 350;
        controls.addEventListener('start', ()=>{ isGraphDragging = true; });
        controls.addEventListener('end', ()=>{ isGraphDragging = false; });

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(8,15,10);
        scene.add(dirLight);

        graphGroup = new THREE.Group();
        scene.add(graphGroup);

        fetchDOMElements();
        setupAudio();
        buildSearchIndex();

        // Precompute connection counts
        const connectionCounts = new Map();
        graphDataFull.nodes.forEach(n => connectionCounts.set(n.id, 0));
        graphDataFull.edges.forEach(e => {
            connectionCounts.set(e.source, (connectionCounts.get(e.source)||0)+1);
            connectionCounts.set(e.target, (connectionCounts.get(e.target)||0)+1);
        });

        createNodes(connectionCounts);
        createEdges();

        window.addEventListener('resize', onWindowResize);
        document.addEventListener('click', onDocumentClick, false);

        animate();
    }

    function createNodes(connectionCounts) {
        const nodeCategories = {};
        graphDataFull.nodes.forEach(node => {
            const category = getNodeCategory(node);
            if (!nodeCategories[category]) nodeCategories[category] = [];
            nodeCategories[category].push(node);
        });

        const categoryRadii = {
            'Person': 0, 'Core Domains': 12, 'Leadership Roles': 22,
            'Problems to Solve': 28, 'Core Values': 34, 'Life Purpose & Goals': 40,
            'Sources of Knowledge': 46, 'Key Concepts': 52
        };
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));

        Object.entries(nodeCategories).forEach(([category, nodesInCategory]) => {
            const radius = categoryRadii[category] !== undefined ? categoryRadii[category] : 60;
            const count = nodesInCategory.length;
            nodesInCategory.forEach((nodeData, i) => {
                const nodeGroup = new THREE.Group();
                nodeData.randomOffset = Math.random() * 1000;

                if (nodeData.id !== 'Akbar') {
                    const y = (count > 1) ? 1 - (i / (count - 1)) * 2 : 0;
                    const radiusAtY = Math.sqrt(Math.max(0, 1 - y*y));
                    const theta = goldenAngle * i;
                    nodeGroup.position.set(Math.cos(theta) * radiusAtY * radius, y * radius, Math.sin(theta) * radiusAtY * radius);
                }

                const colorHex = nodeColorsFull[nodeData.type] || nodeColorsFull.default || 0xa9a9a9;
                nodeData.originalColor = new THREE.Color(colorHex);

                const isAkbar = nodeData.id === 'Akbar';
                const size = isAkbar ? 1.5 : NODE_SIZE;

                const sphereGeo = new THREE.SphereGeometry(size, 32, 16);
                const sphereMat = new THREE.MeshStandardMaterial({
                    color: nodeData.originalColor, transparent:true, opacity: NORMAL_NODE_OPACITY, metalness:0.2, roughness:0.7, emissive:0x000000
                });
                const sphere = new THREE.Mesh(sphereGeo, sphereMat);
                // ensure raycast + property lookups work:
                sphere.userData = sphere.userData || {};
                sphere.userData.nodeData = nodeData;
                sphere.userData.isNodeSphere = true;
                // also set direct property for getObjectByProperty usage
                sphere.isNodeSphere = true;

                nodeGroup.add(sphere);

                // rings (decor)
                const ringsGroup = new THREE.Group();
                const ringCount = connectionCounts.get(nodeData.id) || 0;
                for (let j=0;j<ringCount;j++){
                    const ringRadius = (size*1.3) + j*(size*0.25);
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(ringRadius, ringRadius + 0.05, 64),
                        new THREE.MeshBasicMaterial({
                            color: isAkbar ? AKBAR_RING_COLOR : nodeData.originalColor,
                            side: THREE.DoubleSide, transparent:true, opacity: isAkbar ? AKBAR_RING_OPACITY : DEFAULT_RING_OPACITY
                        })
                    );
                    ring.rotation.x = Math.random()*Math.PI;
                    ring.rotation.y = Math.random()*Math.PI;
                    ringsGroup.add(ring);
                }
                nodeGroup.add(ringsGroup);
                nodeGroup.userData.ringsGroup = ringsGroup;

                // label (CSS2D)
                const labelDiv = document.createElement('div');
                labelDiv.className = 'node-label';
                labelDiv.textContent = nodeData.displayText || nodeData.id;
                labelDiv.setAttribute('data-id', nodeData.id);
                const label = new THREE.CSS2DObject(labelDiv);
                label.position.set(0, size*1.5, 0);
                nodeGroup.add(label);

                nodeGroup.userData.nodeData = nodeData;
                nodeGroup.userData.label = label;

                nodes.set(nodeData.id, nodeGroup);
                graphGroup.add(nodeGroup);
            });
        });
    }

    function createEdges() {
        graphDataFull.edges.forEach(edgeData => {
            const sourceNode = nodes.get(edgeData.source);
            const targetNode = nodes.get(edgeData.target);
            if (!sourceNode || !targetNode) return;

            const startVec = sourceNode.position.clone();
            const endVec = targetNode.position.clone();

            const midPoint = new THREE.Vector3().addVectors(startVec, endVec).multiplyScalar(0.5);
            const distance = startVec.distanceTo(endVec);
            const controlPoint = midPoint.clone().normalize().multiplyScalar(midPoint.length() + distance * 0.8);
            const mainCurve = new THREE.QuadraticBezierCurve3(startVec, controlPoint, endVec);

            const color = relationToColor(edgeData.relation || 'rel');
            const c = new THREE.Color(color);

            const dnaGroup = createDnaStrands(mainCurve, c, edgeData.source === 'Akbar');
            graphGroup.add(dnaGroup);

            const labelDiv = document.createElement('div');
            labelDiv.className = 'edge-relation-label';
            labelDiv.textContent = edgeData.relation;
            labelDiv.setAttribute('data-source', edgeData.source);
            labelDiv.setAttribute('data-target', edgeData.target);
            labelDiv.setAttribute('data-relation', edgeData.relation);
            const label = new THREE.CSS2DObject(labelDiv);
            label.position.copy(mainCurve.getPoint(0.5));
            graphGroup.add(label);

            edges.push(Object.assign({}, edgeData, { mesh: dnaGroup, label, originalColor: c }));
        });
    }

    function createDnaStrands(mainCurve, color, flowsFromAkbar) {
        const numTurns = Math.max(2, mainCurve.getLength() / 4);
        const pointsPerStrand = 64;

        const frames = getSimpleFrenetFrames(mainCurve, pointsPerStrand);
        const { points, normals, binormals } = frames;
        const strandPoints1 = [], strandPoints2 = [];
        for (let i=0;i<=pointsPerStrand;i++){
            const t = i/pointsPerStrand;
            const pointOnCurve = points[i];
            const angle = t * numTurns * Math.PI * 2;
            const offset = normals[i].clone().multiplyScalar(Math.cos(angle) * DNA_HELIX_RADIUS)
                           .add(binormals[i].clone().multiplyScalar(Math.sin(angle) * DNA_HELIX_RADIUS));
            strandPoints1.push(pointOnCurve.clone().add(offset));
            strandPoints2.push(pointOnCurve.clone().add(offset.clone().negate()));
        }

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uColor: { value: color },
                uTime: { value: 0 },
                uFlowSpeed: { value: flowsFromAkbar ? 4.0 : -4.0 },
                uIsHighlighted: { value: 0.0 }
            },
            vertexShader: flowVertexShader,
            fragmentShader: flowFragmentShader,
            transparent: true,
            depthWrite: false,
        });

        const tubeGeo1 = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(strandPoints1), pointsPerStrand, DNA_STRAND_RADIUS, 8, false);
        const tubeGeo2 = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(strandPoints2), pointsPerStrand, DNA_STRAND_RADIUS, 8, false);

        const dnaGroup = new THREE.Group();
        dnaGroup.add(new THREE.Mesh(tubeGeo1, material));
        dnaGroup.add(new THREE.Mesh(tubeGeo2, material.clone()));
        return dnaGroup;
    }

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();
        controls && controls.update();

        if (!isGraphDragging) {
            graphGroup.rotation.y += autoRotationSpeed * delta * 60;
        }

        updateRingOrbits(delta);
        updateEdgeAnimation(time);
        if (highlightedElements) updateHighlightEffect(time);

        renderer.render(scene, camera);
        labelRenderer.render(scene, camera);
    }

    // ---------- Interaction & highlight ----------
    function onDocumentClick(event) {
        // label clicks first (HTML elements)
        if (event.target.classList && event.target.classList.contains('node-label')) {
            const id = event.target.getAttribute('data-id');
            const nodeData = graphDataFull.nodes.find(n => n.id === id);
            if (nodeData) applyHighlight(nodeData);
            return;
        }
        if (event.target.classList && event.target.classList.contains('edge-relation-label')) {
            const src = event.target.getAttribute('data-source');
            const tgt = event.target.getAttribute('data-target');
            const rel = event.target.getAttribute('data-relation');
            const ed = graphDataFull.edges.find(e => e.source === src && e.target === tgt && e.relation === rel);
            if (ed) applyEdgeHighlight(ed);
            return;
        }

        // 3D pick
        if (!renderer) return;
        mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
        mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(graphGroup.children, true);

        let clickedNodeData = null;
        if (intersects && intersects.length) {
            for (const inter of intersects) {
                // check property set on mesh
                if (inter.object && (inter.object.userData && inter.object.userData.isNodeSphere || inter.object.isNodeSphere)) {
                    clickedNodeData = inter.object.userData.nodeData || inter.object.userData.node;
                    break;
                }
            }
        }

        if (clickedNodeData) applyHighlight(clickedNodeData);
        else {
            if (!document.getElementById('info').contains(event.target)) clearHighlights();
        }
    }

    function updateRingOrbits(delta) {
        nodes.forEach(nodeGroup=>{
            if (nodeGroup.userData && nodeGroup.userData.ringsGroup) {
                nodeGroup.userData.ringsGroup.rotation.y += delta * 0.2;
                nodeGroup.userData.ringsGroup.rotation.x += delta * 0.1;
            }
        });
    }

    function updateEdgeAnimation(time) {
        edges.forEach(edge => {
            edge.mesh.children.forEach(child => {
                if (child.material && child.material.uniforms && child.material.uniforms.uTime) {
                    child.material.uniforms.uTime.value = time;
                }
            });
        });
    }

    function updateHighlightEffect(time) {
        const pulseValue = (Math.sin(time * 5) + 1)/2;
        if (highlightedElements && highlightedElements.nodes) {
            highlightedElements.nodes.forEach(nodeData => {
                const nodeGroup = nodes.get(nodeData.id);
                if (nodeGroup) {
                    const sphere = nodeGroup.getObjectByProperty && nodeGroup.getObjectByProperty('isNodeSphere', true) || nodeGroup.children.find(c => c.isNodeSphere);
                    if (sphere) {
                        const baseColor = nodeData.id === (highlightedElements.clickedNode && highlightedElements.clickedNode.id) ? HIGHLIGHT_COLOR : nodeData.originalColor || new THREE.Color(0xffffff);
                        if (sphere.material && sphere.material.emissive) {
                            sphere.material.emissive.copy(baseColor).multiplyScalar(pulseValue * 0.8);
                        }
                    }
                }
            });
        }
    }

    function clearHighlights() {
        if (!highlightedElements) return;
        nodes.forEach(nodeGroup=>{
            const sphere = nodeGroup.getObjectByProperty && nodeGroup.getObjectByProperty('isNodeSphere', true) || nodeGroup.children.find(c => c.isNodeSphere);
            if (sphere && sphere.material) {
                sphere.material.opacity = NORMAL_NODE_OPACITY;
                if (sphere.material.emissive) sphere.material.emissive.setHex(0x000000);
            }
            if (nodeGroup.userData && nodeGroup.userData.label) nodeGroup.userData.label.element.style.opacity = 1;
        });
        edges.forEach(edge=>{
            edge.mesh.children.forEach(child=>{
                if (child.material && child.material.uniforms && child.material.uniforms.uIsHighlighted) child.material.uniforms.uIsHighlighted.value = 0.0;
            });
            if (edge.label) edge.label.element.style.opacity = 1;
        });
        highlightedElements = null;
        if (nodeInspectorDisplay) nodeInspectorDisplay.style.display = 'none';
    }

    function applyHighlight(clickedNodeData) {
        if (!clickedNodeData) return;
        clearHighlights();

        const connectedEdges = edges.filter(e => e.source === clickedNodeData.id || e.target === clickedNodeData.id);
        const connectedNodes = new Set([clickedNodeData]);
        connectedEdges.forEach(edge=>{
            const s = graphDataFull.nodes.find(n=>n.id===edge.source);
            const t = graphDataFull.nodes.find(n=>n.id===edge.target);
            if (s) connectedNodes.add(s);
            if (t) connectedNodes.add(t);
        });

        highlightedElements = { clickedNode: clickedNodeData, nodes: connectedNodes, edges: new Set(connectedEdges) };

        nodes.forEach(nodeGroup=>{
            const isHighlighted = Array.from(connectedNodes).some(n => n.id === nodeGroup.userData.nodeData.id);
            const sphere = nodeGroup.getObjectByProperty && nodeGroup.getObjectByProperty('isNodeSphere', true) || nodeGroup.children.find(c => c.isNodeSphere);
            if (sphere && sphere.material) sphere.material.opacity = isHighlighted ? HIGHLIGHT_OPACITY : FAINT_OPACITY;
            if (nodeGroup.userData && nodeGroup.userData.label) nodeGroup.userData.label.element.style.opacity = isHighlighted ? 1 : FAINT_OPACITY;
        });

        edges.forEach(edge=>{
            const isHighlighted = highlightedElements.edges.has(edge);
            edge.mesh.children.forEach(child=>{
                if (child.material && child.material.uniforms && child.material.uniforms.uIsHighlighted) child.material.uniforms.uIsHighlighted.value = isHighlighted ? 1.0 : 0.0;
            });
            if (edge.label) edge.label.element.style.opacity = isHighlighted ? 1 : FAINT_OPACITY;
        });

        displayNodeInfo(clickedNodeData, connectedEdges);
    }

    function applyEdgeHighlight(edgeData) {
        if (!edgeData) return;
        clearHighlights();

        const sourceNodeData = graphDataFull.nodes.find(n => n.id === edgeData.source);
        const targetNodeData = graphDataFull.nodes.find(n => n.id === edgeData.target);
        const thisEdge = edges.find(e => e.source === edgeData.source && e.target === edgeData.target && e.relation === edgeData.relation);
        if (!sourceNodeData || !targetNodeData || !thisEdge) return;

        highlightedElements = { clickedNode: null, nodes: new Set([sourceNodeData, targetNodeData]), edges: new Set([thisEdge]) };

        nodes.forEach(nodeGroup=>{
            const isHighlighted = nodeGroup.userData.nodeData.id === sourceNodeData.id || nodeGroup.userData.nodeData.id === targetNodeData.id;
            const sphere = nodeGroup.getObjectByProperty && nodeGroup.getObjectByProperty('isNodeSphere', true) || nodeGroup.children.find(c => c.isNodeSphere);
            if (sphere && sphere.material) sphere.material.opacity = isHighlighted ? HIGHLIGHT_OPACITY : FAINT_OPACITY;
            if (nodeGroup.userData && nodeGroup.userData.label) nodeGroup.userData.label.element.style.opacity = isHighlighted ? 1 : FAINT_OPACITY;
        });

        edges.forEach(edge=>{
            const isHighlighted = edge === thisEdge;
            edge.mesh.children.forEach(child=>{
                if (child.material && child.material.uniforms && child.material.uniforms.uIsHighlighted) child.material.uniforms.uIsHighlighted.value = isHighlighted ? 1.0 : 0.0;
            });
            if (edge.label) edge.label.element.style.opacity = isHighlighted ? 1 : FAINT_OPACITY;
        });

        displayNodeInfo(sourceNodeData, [thisEdge]);
    }

    // ---------- UI & search ----------
    function fetchDOMElements() {
        nodeInspectorDisplay = document.getElementById('node-inspector-display');
        nodeIdText = document.getElementById('node-id-text');
        nodeTypeText = document.getElementById('node-type-text');
        nodeCategoryText = document.getElementById('node-category-text');
        nodeConnectionsDetails = document.getElementById('node-connections-details');
        nodeConnectionsList = document.getElementById('node-connections-list');
        searchBox = document.getElementById('search-box');
        searchSuggestions = document.getElementById('search-suggestions');
        musicToggleBtn = document.getElementById('music-toggle');
        musicStatusDiv = document.getElementById('music-status');

        searchBox.addEventListener('input', handleSearchInput);
        searchBox.addEventListener('keydown', (e)=>{
            if (e.key === 'Enter') {
                const firstSuggestion = searchSuggestions.querySelector('.suggestion-item');
                if (firstSuggestion) { const nodeData = searchIndex.find(n=>n.id===firstSuggestion.dataset.id); if(nodeData) { applyHighlight(nodeData); searchBox.value = nodeData.displayText; clearSuggestions(); } }
            }
        });

        // music toggle
        musicToggleBtn.addEventListener('click', () => {
            if (!audioPlayer) return;
            if (audioPlayer.paused) {
                audioPlayer.play().then(()=>{ updateMusicUI(true); }).catch(err=>{ console.warn('Playback blocked or failed', err); updateMusicUI(false); });
            } else {
                audioPlayer.pause();
                updateMusicUI(false);
            }
        });

        // allow single click on page to unmute/resume audio policies
        document.addEventListener('pointerdown', () => {
            if (audioPlayer && audioPlayer.paused && musicStatusDiv.dataset.autoplayAttempted !== 'true') {
                // intentionally do not autoplay, but mark we've had interaction
                musicStatusDiv.dataset.autoplayAttempted = 'true';
            }
        }, { once: true });
    }

    function handleSearchInput(e) {
        const term = e.target.value.toLowerCase();
        clearSuggestions();
        if (!term || term.length < 2) return;
        const results = searchIndex.filter(n => n.name.includes(term)).slice(0, 6);
        results.forEach(node=>{
            const d = document.createElement('div');
            d.className = 'suggestion-item';
            d.textContent = node.displayText;
            d.dataset.id = node.id;
            d.addEventListener('click', (ev)=> {
                ev.stopPropagation();
                const nd = searchIndex.find(x => x.id === ev.target.dataset.id);
                if (nd) { applyHighlight(nd); searchBox.value = nd.displayText; clearSuggestions(); }
            });
            searchSuggestions.appendChild(d);
        });
    }

    function clearSuggestions(){ if (searchSuggestions) searchSuggestions.innerHTML = ''; }

    function buildSearchIndex() {
        searchIndex = graphDataFull.nodes.map(node => ({
            id: node.id,
            name: (node.displayText || node.id).toLowerCase(),
            displayText: node.displayText || node.id,
            ...node
        }));
    }

    function displayNodeInfo(nodeData, connectedEdges) {
        nodeIdText.textContent = nodeData.displayText || nodeData.id;
        nodeTypeText.textContent = nodeData.type || '-';
        nodeCategoryText.textContent = getNodeCategory(nodeData);
        nodeConnectionsList.innerHTML = '';
        connectedEdges.forEach(edge=>{
            const other = edge.source === nodeData.id ? edge.target : edge.source;
            const otherNode = graphDataFull.nodes.find(n=>n.id===other);
            const li = document.createElement('li');
            li.innerHTML = `${edge.relation} <strong>${otherNode ? (otherNode.displayText || otherNode.id) : other}</strong>`;
            nodeConnectionsList.appendChild(li);
        });
        nodeConnectionsDetails.style.display = connectedEdges.length ? 'block' : 'none';
        nodeInspectorDisplay.style.display = 'block';
    }

    // ---------- audio ----------
    function setupAudio() {
        audioPlayer = new Audio(BG_AUDIO_SRC);
        audioPlayer.loop = true;
        audioPlayer.preload = 'auto';
        audioPlayer.crossOrigin = 'anonymous';
        updateMusicUI(false);
        audioPlayer.addEventListener('play', ()=> updateMusicUI(true));
        audioPlayer.addEventListener('pause', ()=> updateMusicUI(false));
        audioPlayer.addEventListener('error', (e) => {
            console.warn('Audio error', e);
            musicStatusDiv.textContent = 'Audio failed to load. Upload MP3 to assets/ and confirm path.';
        });
    }

    function updateMusicUI(isPlaying) {
        musicToggleBtn.textContent = isPlaying ? 'Pause Music' : 'Play Music';
        musicStatusDiv.textContent = isPlaying ? 'Playing — Daft Punk: End of Line' : 'Stopped';
    }

    // ---------- resize ----------
    function onWindowResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ---------- bootstrap: load your full graph JSON here ----------
    // Replace the example below with your full JSON if needed.
    (function loadDefaultGraph(){
        // If you already uploaded the large JSON earlier, simply paste it here.
        // For demo minimal nodes (so you don't get an empty scene), we'll include a small fallback:
        const fallback = {
            nodes: [
                { id: "Akbar", type: "Person", displayText: "Akbar" },
                { id: "Law_Domain", type: "DomainOfKnowledge", displayText: "Law" },
                { id: "Human_Rights_Domain", type: "DomainOfKnowledge", displayText: "Human Rights" }
            ],
            edges: [
                { source: "Akbar", target: "Law_Domain", relation: "studies" },
                { source: "Akbar", target: "Human_Rights_Domain", relation: "advocates_in" }
            ]
        };
        // If you have a big JSON string to paste, replace 'fallback' with your data
        Object.assign(graphDataFull, fallback);

        // example nodeColors (optional) - you can replace with your full mapping
        Object.assign(nodeColorsFull, {
            "Person":0xFF6347, "DomainOfKnowledge":0x4A90E2, "default":0xA9A9A9
        });
    })();

    // ---------- start ----------
    window.addEventListener('load', () => {
        try {
            init();
            console.log('Graph initialized. Nodes:', graphDataFull.nodes.length);
        } catch (err) {
            console.error('Initialization error', err);
            const errDiv = document.createElement('div');
            errDiv.style.cssText = 'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#111;color:#fff;padding:16px;border-radius:8px;z-index:9999';
            errDiv.innerHTML = '<strong>Initialization error:</strong><pre style="white-space:pre-wrap;color:#f88;">'+ (err && err.message ? err.message : String(err)) +'</pre>';
            document.body.appendChild(errDiv);
        }
    });
    </script>
</body>
</html>


